# -*- coding: utf-8 -*-
"""Untitled21.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1nCzO57ZwPpG0787m-Sq-WfCx8zr5qjg5
"""

#SENTENCIA TRY/EXCEPT
def division(numero):
    try:
        resultado = 10 / numero
        print('el total de la division es',resultado)
    except ZeroDivisionError:
        print('No es posible realizar la division por cero...')
division('a')
print('Este es un print fuera de la sentencia try-except')

# CAPTURANDO MULTIPLES ERRORES TRY-EXCEPT
def division2(numero):
    try:
        if numero == 13:
            # NOS PERMITE LEVANTAR UN ERROR MANUALMENTE QUE INDIQUEMOS
            raise ValueError('13 es un numero de mala suerte...')
        return 100/numero
    except (ZeroDivisionError, TypeError):
        return 'Ingresar otro numero que no sea cero...'
for elemento in (0,'texto',30,13):
    print(f'Probando {elemento}:', end="")  
    print(division2(elemento))

# CAPTURANDO MULTIPLES ERRORES TRY-EXCEPT
def division3(numero):
    try:
        if numero == 13:
            # NOS PERMITE LEVANTAR UN ERROR MANUALMENTE QUE INDIQUEMOS
            raise ValueError('13 es un numero de mala suerte...')
        return 100/numero
    except ZeroDivisionError:
        return 'Ingresar otro numero que no sea cero...'
    except TypeError:
        return 'Ingresar un valor numerico...'
    except ValueError:
        return '13 es un numero de mala suerte...'
for elemento in (0,'texto',30,13):
    print(f'Probando {elemento}:', end="")  
    print(division3(elemento))

# CAPTURANDO MULTIPLES ERRORES TRY-EXCEPT Y GUARDANDOLOS EN UNA VARIABLE
def division4(numero):
    try:
        if numero == 13:
            # NOS PERMITE LEVANTAR UN ERROR MANUALMENTE QUE INDIQUEMOS
            raise ValueError('13 es un numero de mala suerte...')
        return 100/numero
    except ZeroDivisionError as e:
        print('Ingresar otro numero que no sea cero...', e) 
    except TypeError as ex:
        print('Ingresar un valor numerico...', ex) 
    except ValueError as exc:
        print('El numero 13, es un numero de mala suerte...', exc)
for elemento in (0,'texto',30,13):
    print(f'Probando {elemento}:', end="")  
    print(division4(elemento))

# THROW DE EXCEPECIONES 
class SoloPares(list):
    def append(self, entero):
        if not isinstance(entero, int):
            raise TypeError('Solo enteros pueden ser agregados...')
        
        if entero % 2:
            raise ValueError('Solo numeros pares pueden ser agregados...')
        super().append(entero)

numero = SoloPares()
numero.append(2)

# EXCEPECIONES DEFINIDAD POR EL USUARIO
class RetiroInvalido(Exception):
    def __init__(self, balance, monto):
        super().__init__(f'La cuenta no tiene ${monto}')
        self.monto = monto 
        self.balance = balance
    def exceso(self):
        return self.monto - self.balance

try:
    raise RetiroInvalido(50, 100)
except RetiroInvalido as e:
    print(f'Lo sentimos, pero su retiro es mas que su balance ${e.exceso()}')

# ACCIONES DE LIMPIEZA CON FINALLY

import random 
lista_excepciones = [ValueError, TypeError, IndexError, None]
try:
    alternativa = random.choice(lista_excepciones)
    print(f'Lanzando : {alternativa}')
    if alternativa: 
        raise alternativa('Error')
except ValueError:
    print('Atrapando un ValueError')
except TypeError:
    print('Atrapando un TypeError')
except IndexError:
    print('Atrapando un IndexError')
else:
    print('Este bloque solamente se ejecuta si no existe ninguna excepecion')
finally:
    print('Este bloque siempre se ejecutara')

# ACCIONES DE LIMPIEZA PREDEFINIDA